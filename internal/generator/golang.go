package generator

import (
	"fmt"
	"strings"

	"github.com/rasmartins/typemux/internal/ast"
)

// GoGenerator generates Go code from TypeMUX schemas.
type GoGenerator struct{}

// NewGoGenerator creates a new Go code generator.
func NewGoGenerator() *GoGenerator {
	return &GoGenerator{}
}

// Generate creates Go code from the given schema.
func (g *GoGenerator) Generate(schema *ast.Schema) string {
	var sb strings.Builder

	// Package declaration
	packageName := g.getPackageName(schema.Namespace)

	// Check for @go.package annotation at namespace level
	if schema.NamespaceAnnotations != nil && len(schema.NamespaceAnnotations.Go) > 0 {
		for _, goAnnotation := range schema.NamespaceAnnotations.Go {
			if strings.HasPrefix(goAnnotation, "package") {
				// Extract package name from 'package = "mypackage"' format
				parts := strings.Split(goAnnotation, "=")
				if len(parts) == 2 {
					packageName = strings.Trim(strings.TrimSpace(parts[1]), "\"")
				}
			}
		}
	}

	sb.WriteString("// Code generated by TypeMUX. DO NOT EDIT.\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Imports
	needsTime := g.needsTimeImport(schema)
	if needsTime {
		sb.WriteString("import (\n")
		sb.WriteString("\t\"time\"\n")
		sb.WriteString(")\n\n")
	}

	// Generate enums
	for _, enum := range schema.Enums {
		sb.WriteString(g.generateEnum(enum))
		sb.WriteString("\n")
	}

	// Generate types
	for _, typ := range schema.Types {
		sb.WriteString(g.generateType(typ))
		sb.WriteString("\n")
	}

	// Generate unions
	for _, union := range schema.Unions {
		sb.WriteString(g.generateUnion(union))
		sb.WriteString("\n")
	}

	// Generate service interfaces
	for _, service := range schema.Services {
		sb.WriteString(g.generateService(service))
		sb.WriteString("\n")
	}

	return sb.String()
}

// getPackageName converts a namespace to a valid Go package name
func (g *GoGenerator) getPackageName(namespace string) string {
	if namespace == "" {
		return "api"
	}

	// Take the last component of the namespace
	// e.g., "com.example.users" -> "users"
	parts := strings.Split(namespace, ".")
	pkgName := parts[len(parts)-1]

	// Make it lowercase and remove invalid characters
	pkgName = strings.ToLower(pkgName)
	pkgName = strings.ReplaceAll(pkgName, "-", "")
	pkgName = strings.ReplaceAll(pkgName, "_", "")

	return pkgName
}

// needsTimeImport checks if the schema uses timestamp types
func (g *GoGenerator) needsTimeImport(schema *ast.Schema) bool {
	for _, typ := range schema.Types {
		for _, field := range typ.Fields {
			if field.Type.Name == "timestamp" {
				return true
			}
		}
	}
	return false
}

// generateEnum generates Go code for an enum
func (g *GoGenerator) generateEnum(enum *ast.Enum) string {
	var sb strings.Builder

	// Generate documentation
	if enum.Doc != nil {
		doc := enum.Doc.GetDoc("go")
		if doc == "" {
			doc = enum.Doc.General
		}
		if doc != "" {
			sb.WriteString(g.formatComment(doc))
		}
	}

	// Type definition
	sb.WriteString(fmt.Sprintf("type %s int\n\n", enum.Name))

	// Const block
	sb.WriteString("const (\n")
	for i, value := range enum.Values {
		// Value documentation
		if value.Doc != nil && value.Doc.General != "" {
			sb.WriteString(fmt.Sprintf("\t// %s\n", strings.TrimSpace(value.Doc.General)))
		}

		// Enum value
		if i == 0 {
			if value.HasNumber {
				sb.WriteString(fmt.Sprintf("\t%s%s %s = %d\n", enum.Name, value.Name, enum.Name, value.Number))
			} else {
				sb.WriteString(fmt.Sprintf("\t%s%s %s = iota\n", enum.Name, value.Name, enum.Name))
			}
		} else {
			if value.HasNumber {
				sb.WriteString(fmt.Sprintf("\t%s%s %s = %d\n", enum.Name, value.Name, enum.Name, value.Number))
			} else {
				sb.WriteString(fmt.Sprintf("\t%s%s\n", enum.Name, value.Name))
			}
		}
	}
	sb.WriteString(")\n")

	return sb.String()
}

// generateType generates Go code for a struct type
func (g *GoGenerator) generateType(typ *ast.Type) string {
	var sb strings.Builder

	// Generate documentation
	if typ.Doc != nil {
		doc := typ.Doc.GetDoc("go")
		if doc == "" {
			doc = typ.Doc.General
		}
		if doc != "" {
			sb.WriteString(g.formatComment(doc))
		}
	}

	// Struct definition
	sb.WriteString(fmt.Sprintf("type %s struct {\n", typ.Name))

	for _, field := range typ.Fields {
		// Field documentation
		if field.Doc != nil && field.Doc.General != "" {
			doc := field.Doc.GetDoc("go")
			if doc == "" {
				doc = field.Doc.General
			}
			// Format multi-line comments properly
			lines := strings.Split(strings.TrimSpace(doc), "\n")
			for _, line := range lines {
				sb.WriteString(fmt.Sprintf("\t// %s\n", strings.TrimSpace(line)))
			}
		}

		// Field definition
		fieldName := g.exportFieldName(field.Name)
		fieldType := g.mapTypeToGo(field.Type)
		jsonTag := g.getJSONTag(field)

		sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, fieldType, jsonTag))
	}

	sb.WriteString("}\n")

	return sb.String()
}

// generateUnion generates Go code for a union type
func (g *GoGenerator) generateUnion(union *ast.Union) string {
	var sb strings.Builder

	// Generate documentation
	if union.Doc != nil {
		doc := union.Doc.GetDoc("go")
		if doc == "" {
			doc = union.Doc.General
		}
		if doc != "" {
			sb.WriteString(g.formatComment(doc))
		}
	}

	// Union as interface
	sb.WriteString(fmt.Sprintf("type %s interface {\n", union.Name))
	sb.WriteString(fmt.Sprintf("\tis%s()\n", union.Name))
	sb.WriteString("}\n\n")

	// Generate concrete types for each option
	for _, option := range union.Options {
		typeName := fmt.Sprintf("%s%s", union.Name, option)
		sb.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
		sb.WriteString(fmt.Sprintf("\tValue %s `json:\"value\"`\n", option))
		sb.WriteString("}\n\n")
		sb.WriteString(fmt.Sprintf("func (%s) is%s() {}\n\n", typeName, union.Name))
	}

	return sb.String()
}

// generateService generates Go code for a service interface
func (g *GoGenerator) generateService(service *ast.Service) string {
	var sb strings.Builder

	// Generate documentation
	if service.Doc != nil {
		doc := service.Doc.GetDoc("go")
		if doc == "" {
			doc = service.Doc.General
		}
		if doc != "" {
			sb.WriteString(g.formatComment(doc))
		}
	}

	// Service interface
	sb.WriteString(fmt.Sprintf("type %s interface {\n", service.Name))

	for _, method := range service.Methods {
		// Method documentation
		if method.Doc != nil && method.Doc.General != "" {
			sb.WriteString(fmt.Sprintf("\t// %s\n", strings.TrimSpace(method.Doc.General)))
		}

		// Method signature
		inputType := g.cleanTypeName(method.InputType)
		outputType := g.cleanTypeName(method.OutputType)

		if method.OutputStream {
			sb.WriteString(fmt.Sprintf("\t%s(input *%s, stream chan *%s) error\n", method.Name, inputType, outputType))
		} else {
			sb.WriteString(fmt.Sprintf("\t%s(input *%s) (*%s, error)\n", method.Name, inputType, outputType))
		}
	}

	sb.WriteString("}\n")

	return sb.String()
}

// mapTypeToGo maps TypeMUX types to Go types
func (g *GoGenerator) mapTypeToGo(fieldType *ast.FieldType) string {
	var goType string

	// Handle base type
	switch fieldType.Name {
	case "string":
		goType = "string"
	case "int32":
		goType = "int32"
	case "int64":
		goType = "int64"
	case "float32":
		goType = "float32"
	case "float64":
		goType = "float64"
	case "bool":
		goType = "bool"
	case "timestamp":
		goType = "time.Time"
	case "bytes":
		goType = "[]byte"
	default:
		// Custom type
		goType = g.cleanTypeName(fieldType.Name)
	}

	// Handle map type
	if fieldType.MapKey != "" {
		keyType := g.mapScalarTypeToGo(fieldType.MapKey)
		var valueType string
		if fieldType.MapValueType != nil {
			// Complex map value (array, nested map, etc.)
			valueType = g.mapTypeToGo(fieldType.MapValueType)
		} else {
			// Simple map value
			valueType = g.mapScalarTypeToGo(fieldType.MapValue)
		}
		goType = fmt.Sprintf("map[%s]%s", keyType, valueType)
	}

	// Handle array
	if fieldType.IsArray {
		goType = "[]" + goType
	}

	// Handle optional (pointer for structs, not for primitives in Go)
	if fieldType.Optional {
		// Only use pointer for non-primitive types
		if !g.isPrimitiveType(fieldType.Name) {
			goType = "*" + goType
		}
	}

	return goType
}

// mapScalarTypeToGo maps scalar types for maps
func (g *GoGenerator) mapScalarTypeToGo(typeName string) string {
	switch typeName {
	case "string":
		return "string"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "float32":
		return "float32"
	case "float64":
		return "float64"
	case "bool":
		return "bool"
	default:
		return g.cleanTypeName(typeName)
	}
}

// isPrimitiveType checks if a type is a primitive Go type
func (g *GoGenerator) isPrimitiveType(typeName string) bool {
	primitives := map[string]bool{
		"string":  true,
		"int32":   true,
		"int64":   true,
		"float32": true,
		"float64": true,
		"bool":    true,
		"bytes":   true,
	}
	return primitives[typeName]
}

// cleanTypeName removes namespace prefixes from type names
func (g *GoGenerator) cleanTypeName(typeName string) string {
	// Remove namespace prefix (e.g., "com.example.User" -> "User")
	parts := strings.Split(typeName, ".")
	return parts[len(parts)-1]
}

// exportFieldName converts a field name to exported Go format
func (g *GoGenerator) exportFieldName(name string) string {
	if name == "" {
		return ""
	}

	// Convert to PascalCase
	parts := strings.Split(name, "_")
	for i, part := range parts {
		if part != "" {
			parts[i] = strings.ToUpper(part[0:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

// getJSONTag generates the JSON tag for a field
func (g *GoGenerator) getJSONTag(field *ast.Field) string {
	tag := field.Name
	if field.Type.Optional {
		tag += ",omitempty"
	}
	return tag
}

// formatComment formats a comment for Go code
func (g *GoGenerator) formatComment(comment string) string {
	lines := strings.Split(strings.TrimSpace(comment), "\n")
	var result strings.Builder
	for _, line := range lines {
		result.WriteString("// ")
		result.WriteString(strings.TrimSpace(line))
		result.WriteString("\n")
	}
	return result.String()
}
